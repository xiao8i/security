#  栈向内存的低地址生长，即栈底在高地址，数据向内存高地址生长，即高位低地址
一个程序的运行栈http://blog.csdn.net/lieist/article/details/44110475
汇编语言：寄存器可以认为是特殊的内存空间，注意区分是对寄存器操作（区分ip类的值有命令索引地址功能，而ax类就是值），还是对内存空间进行操作。通过CS：IP指向当前指令，执行指令后IP自动到下一指令处。通过SS：SP指向栈顶。通过ds：【】对内存空间数据进行处理（也可以通过栈的push、pop）
	jmp 3:0B16 CS=0003H，IP=0B16H 意思是命令指向地址为10B16H的内存（注只能在debug中使用，编译报错）若要修改cs可以jmp dword ptr ds：【0】或者jmp dword ptr 【bx】，因为cs是段寄存器
	jmp ax  用ax寄存器的值修改IP
	mov ax，1000H ax寄存器存储1000H，ax等寄存器没有指向功能
	mov ds，ax  ds数据段寄存器存储ax值，并通过ds【】形式指向数据（注mov 指令不能在段寄存器cs、ds、ss和数据间进行，段寄存器和寄存器/内存单元【】则可）（且应用jmp替代mov操作cs、ip）
	（）取值，例如push ax为（sp）=（sp）-2  （（ss）*16+（sp））=（ax）
	【】为偏移地址
	汇编程序数据不能以字母开头，高位补0，例如0ffffH
	0:200~0:2ff一般可以随意使用
	【200+bx】与200【bx】和【bx】.200等价
	在需要暂存数据的时候，应该使用栈，更方便
	【】默认ds为段地址，除了【bp】段地址为ss
	寻址【bx】.idata【si】与C一致
	call 标号：要先将cs、ip入栈 ret：ip获得栈顶内容 retf：cs：ip获得栈顶内容 call、ret配对用其实call标号相当于push ip jump标号，ret就是pop ip
	ROM存放程序BIOS，存放硬件检测和初始化程序，还有中断例程。操作系统DOS也有中断例程，并一般通过DOS的中断例程运行自己设计的程序。
	cli、程序、sti将保证程序不会中断
C语言：char a开辟一块内存空间存储字符串，并用a代表（即看到a就是字符串）
	char * b 开辟一块内存空间存储字符串a的地址，并用b代表（即看到b就是字符串地址）
	char ** c 开辟一块内存空间存储字符串指针的地址，并用c代表（即看到c就是字符串指针的地址）
	& 取地址scanf("%d",&a)  scanf("%s",b)字符串b是字符数组char b[]="XXX"的首地址，所以不需要取地址&，同理数组名也是地址，函数名也是地址。且不允许str1=str2
	for（int i =1;i<10;i++）
	{
	；	
	}
	{
	int a;  //a只在复合语句内有效
	}
	static有两种意思，对局部变量声明不释放，对全局变量和函数声明不可被其他模块extern。
	*表示指向/取值，例如int *p = d,则p=&d，*p=d
	struct Name
	{
	;};且p ->结构体成员名等价(*p).成员名
	区分int * p(void)；指针函数int (* p)(void)；函数指针（需要* p()来调用）；  int * p[4];指针数组   int (* p)[4];数组指针
python：a = 1 开辟内存空间a指向1，先开辟一块内存空间R存储1，令开辟内存空间a存储R的地址，即a是一个地址。
	b = a 开辟内存空间b也指向a的对象，即b也存储一份地址。
	python里一切皆对象，都当地址处理。
